<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="bloodhound技术分析"><meta name="keywords" content="bloodhound"><meta name="author" content="rootrain"><meta name="copyright" content="rootrain"><title>bloodhound技术分析 | rootrain's Home</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#工具使用"><span class="toc-number">1.</span> <span class="toc-text">工具使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#联动cobaltstrike"><span class="toc-number">1.1.</span> <span class="toc-text">联动cobaltstrike</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#目标选择和API使用"><span class="toc-number">2.</span> <span class="toc-text">目标选择和API使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#本地管理员"><span class="toc-number">2.1.</span> <span class="toc-text">本地管理员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-number">2.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数"><span class="toc-number">2.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展思路"><span class="toc-number">2.1.3.</span> <span class="toc-text">扩展思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#会话"><span class="toc-number">2.2.</span> <span class="toc-text">会话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认会话"><span class="toc-number">2.2.1.</span> <span class="toc-text">默认会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语法-1"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数-1"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#扩展思路-1"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">扩展思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LoggedOn会话"><span class="toc-number">2.2.2.</span> <span class="toc-text">LoggedOn会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语法-2"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数-2"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组成员关系"><span class="toc-number">2.3.</span> <span class="toc-text">组成员关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACL"><span class="toc-number">2.4.</span> <span class="toc-text">ACL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#域信任关系"><span class="toc-number">2.5.</span> <span class="toc-text">域信任关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象属性"><span class="toc-number">2.6.</span> <span class="toc-text">对象属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#每种收集方法的目标是什么系统？"><span class="toc-number">3.</span> <span class="toc-text">每种收集方法的目标是什么系统？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#本地管理员-非隐秘"><span class="toc-number">3.1.</span> <span class="toc-text">本地管理员 - 非隐秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地管理员-隐秘"><span class="toc-number">3.2.</span> <span class="toc-text">本地管理员 - 隐秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#会话-非隐秘"><span class="toc-number">3.3.</span> <span class="toc-text">会话 - 非隐秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#会话-隐秘"><span class="toc-number">3.4.</span> <span class="toc-text">会话 - 隐秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组-隐秘与非隐秘"><span class="toc-number">3.5.</span> <span class="toc-text">组- 隐秘与非隐秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACL-隐秘和非隐秘"><span class="toc-number">3.6.</span> <span class="toc-text">ACL - 隐秘和非隐秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#信任关系-隐秘和非隐秘"><span class="toc-number">3.7.</span> <span class="toc-text">信任关系 - 隐秘和非隐秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象属性-隐秘和非隐秘"><span class="toc-number">3.8.</span> <span class="toc-text">对象属性 - 隐秘和非隐秘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#技术总结"><span class="toc-number">4.</span> <span class="toc-text">技术总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cheat-Sheets"><span class="toc-number">4.1.</span> <span class="toc-text">Cheat Sheets</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">5.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">rootrain</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2020/02/29/BlO4umfeQ8Ao9D3.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rootrain's Home</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a></span></div><div id="post-info"><div id="post-title">bloodhound技术分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/内网/">内网</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>攻击者可以使用BloodHound轻松识别高度复杂的攻击路径。防御者可以使用它来识别和消除那些相同的攻击路径。蓝队和红队都可以使用BloodHound轻松深入了解Active Directory环境中的权限关系。</p>
<p>BloodHound分为两部分，一部分是收集器，通过不同的API调用收集图形所需的信息；另一部分是将集合的信息导入Neo4j数据库中，进行展示分析。</p>
<a id="more"></a>
<h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><p>环境：</p>
<p>kali 2019 vm虚拟机</p>
<p>安装：</p>
<p>apt-get install bloodhound</p>
<p>安装完毕后启动Neo4j和bloodhound</p>
<p>neo4j console</p>
<p>bloodhound</p>
<p>访问<a href="http://localhost:7474修改初始密码，然后登陆bloodhound。" target="_blank" rel="noopener">http://localhost:7474修改初始密码，然后登陆bloodhound。</a></p>
<h2 id="联动cobaltstrike"><a href="#联动cobaltstrike" class="headerlink" title="联动cobaltstrike"></a>联动cobaltstrike</h2><p>官方地址：<a href="https://github.com/BloodHoundAD/BloodHound" target="_blank" rel="noopener">https://github.com/BloodHoundAD/BloodHound</a></p>
<p>cs插件：<a href="https://github.com/C0axx/AggressorScripts" target="_blank" rel="noopener">https://github.com/C0axx/AggressorScripts</a></p>
<p>也可以通过sharpbound.exe和ps1单独使用（execute-assembly、powershell-import）。</p>
<p>导入插件，快速导出并下载bloodhound的json文件。</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-03.jpg" alt></p>
<p>选择任意可用选项</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-04.jpg" alt></p>
<p>使用powerpick</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-05.jpg" alt></p>
<p>在view–&gt;download找到下载的文件</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-06.jpg" alt></p>
<p>导入zip后就可以通过各种关系寻找路线攻击域管或者某台特定机器</p>
<p>寻找攻击域管的最短路径：</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-07.jpg" alt></p>
<p>由于本地搭建的域环境没有过多的关联信息，所以不能很好看出各台机器的关系逻辑。</p>
<p>其他环境效果图：</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-08.jpg" alt></p>
<p>查找具有DCSync权限的主体</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-10.jpg" alt></p>
<p>通过使用该工具，可以在攻击内网的时候有一个明确的路线，大致了解哪些机器及用户的权限是存在价值的，还可以通过当前所获取的权限去判断我们下一步应该去攻击哪些机器，当前的权限是否又与哪些机器有着session交互。</p>
<p>###使用技巧</p>
<p>如果你不想过多了解bloodhound对运行机制，不需要自己编写语法查询，只用bloodhound提供的默认ui显示。那么只需要认识几个图形所代表的意义及一些使用技巧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">绿色用户头像：用户</span><br><span class="line"></span><br><span class="line">三个黄色头像：用户组</span><br><span class="line"></span><br><span class="line">红色小电脑：计算机</span><br><span class="line"></span><br><span class="line">绿色小地球：域</span><br></pre></td></tr></table></figure>
<p><strong>默认提供的ui查询</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Find all Domain Admins                                查找所有域管理员</span><br><span class="line">Find Shortest Paths to Domain Admins                  查找域管理员的最短路径</span><br><span class="line">Find Principals with DCSync Rights                    查找具有DCSync权限的主体</span><br><span class="line">Users with Foreign Domain Group Membership            具有外域组成员身份的用户</span><br><span class="line">Groups with Foreign Domain Group Membership           具有外域组成员身份的组</span><br><span class="line">Map Domain Trusts																			域信任映射图</span><br><span class="line">Shortest Paths to Unconstrained Delegation Systems    不受约束的委派系统的最短路径</span><br><span class="line">Shortest Paths from Kerberoastable Users              来自Kerberoastable用户的最短路径</span><br><span class="line">Shortest Paths to Domain Admins from Kerberoastable Users  可通过Kerberoastable用户访问域管理员的最短路径</span><br><span class="line">Shortest Path from Owned Principals                   已拥有权限最短路径</span><br><span class="line">Shortest Paths to Domain Admins from Owned Principals 已拥有权限到域管理员的最短路径</span><br><span class="line">Shortest Paths to High Value Targets									高价值目标的最短路径</span><br></pre></td></tr></table></figure>
<p><strong>两个关系中的联系解读</strong>：</p>
<p>鼠标移动到路径并出现闪光时，右键–&gt;HELP。</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-12.jpg" alt></p>
<p>出现该关系的释义</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-13.jpg" alt></p>
<p>通过<strong>点</strong>进行关系关联：</p>
<p>如下图，通过点击企业管理员组将会利用闪光列出3条相关联的信息路径。</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-14.jpg" alt></p>
<p>以高价值目标的最短路径举例进行分析</p>
<p>当选择高价值目标的最短路径UI进行分析（选择其他UI使用方式一样），可以重点关注用户（绿色头像）、计算机（红色小电脑）。当用鼠标指向这两个单位时，会以高亮显示体现出具体的攻击路径。简而言之：</p>
<p>1.对高亮攻击路径中的所有用户分析</p>
<p>2.对高亮攻击路径中的所有计算机进行分析</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-15.jpg" alt></p>
<p>找到关键计算机或者关键用户时，可以右键设置最短路径到此处，查询可以获取该用户权限的路径信息。</p>
<p>发现从exchange计算机可以获取该用户权限</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-16.jpg" alt></p>
<p>如同这样，可以遍历默认提供的ui查询中，获取到关键的用户、计算机以及获取它们的相关路径，可以很好的辅助内网渗透中的横向、纵向权限获取。</p>
<p>路径设置</p>
<p>右键设置起点终点，或者在左上角填上起点终点</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-17.jpg" alt></p>
<h1 id="目标选择和API使用"><a href="#目标选择和API使用" class="headerlink" title="目标选择和API使用"></a>目标选择和API使用</h1><p>收集器有几个独立的步骤，它们同时运行以收集图形所需的不同数据。整体细分分为几类：本地管理员，组成员关系，会话，对象属性，ACL和域信任。</p>
<h2 id="本地管理员"><a href="#本地管理员" class="headerlink" title="本地管理员"></a>本地管理员</h2><p>本地管理员集合使用两种不同的方法完成，具体取决于是否指定了隐秘选项。没有隐秘选项的本地管理员收集将首先查询Active Directory以获取计算机列表。计算机列表将传递给枚举运行程序，该运行程序将连接到每台计算机并执行以下操作：</p>
<ul>
<li>在端口445上执行TCP连接以检查主机是否处于活动状态</li>
<li>如果主机处于活动状态，则执行<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370601(v=vs.85" target="_blank" rel="noopener">NetLocalGroupGetMembers NETAPI32</a>.aspx) API。</li>
<li>从NetLocalGroupGetMembers调用返回的数据并将SID解析为实际用户，并过滤掉本地帐户。</li>
</ul>
<p>如果指定了隐秘集合，则SharpHound将向域控制器查询所有组策略容器对象及其对应的<strong>gpcfilesyspath</strong>属性的列表，该属性指示实际组策略文件在域控制器$ SYSVOL目录中的位置。将枚举每个组策略文件，查找模式<em>S-1-5-32-544__Members</em>，它指示本地Administrators组。处理文件以确定应用这些GPO的计算机。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS NET_API_FUNCTION <span class="title">NetLocalGroupGetMembers</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR    servername,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCWSTR    localgroupname,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD      level,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE     *bufptr,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD      prefmaxlen,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD    entriesread,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD    totalentries,</span></span></span><br><span class="line"><span class="function"><span class="params">  PDWORD_PTR resumehandle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>servername</p>
<p>指向常量字符串的指针，该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为<strong>NULL</strong>，则使用本地计算机。</p>
<p>localgroupname</p>
<p>指向常量字符串的指针，该字符串指定要列出其成员的本地组的名称。有关更多信息，请参阅以下备注部分。</p>
<p>level</p>
<p>指定数据的信息级别。此参数可以是以下值之一。</p>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left">返回与本地组成员关联的 <a href="https://docs.microsoft.com/windows/desktop/SecAuthZ/security-identifiers" target="_blank" rel="noopener">安全标识符</a>（SID）。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmaccess/ns-lmaccess-localgroup_members_info_0" target="_blank" rel="noopener">LOCALGROUP_MEMBERS_INFO_0</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>1</strong></td>
<td style="text-align:left">返回与本地组成员关联的SID和帐户信息。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmaccess/ns-lmaccess-localgroup_members_info_1" target="_blank" rel="noopener">LOCALGROUP_MEMBERS_INFO_1</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>2</strong></td>
<td style="text-align:left">返回与本地组成员关联的SID，帐户信息和域名。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmaccess/ns-lmaccess-localgroup_members_info_2" target="_blank" rel="noopener">LOCALGROUP_MEMBERS_INFO_2</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>3</strong></td>
<td style="text-align:left">返回本地组成员的帐户和域名。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmaccess/ns-lmaccess-localgroup_members_info_3" target="_blank" rel="noopener">LOCALGROUP_MEMBERS_INFO_3</a>结构。</td>
</tr>
</tbody>
</table>
<p>NetLocalGroupGetMembers sample code，枚举用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static class NetworkAPI</span><br><span class="line">        &#123;</span><br><span class="line">            [DllImport(&quot;Netapi32.dll&quot;)]</span><br><span class="line">            public extern static int NetLocalGroupGetMembers([MarshalAs(UnmanagedType.LPWStr)] string servername, [MarshalAs(UnmanagedType.LPWStr)] string localgroupname, int level, out IntPtr bufptr, int prefmaxlen, out int entriesread, out int totalentries, out int resumehandle);</span><br><span class="line"></span><br><span class="line">            [DllImport(&quot;Netapi32.dll&quot;)]</span><br><span class="line">            public extern static int NetApiBufferFree(IntPtr Buffer);</span><br><span class="line"></span><br><span class="line">            // LOCALGROUP_MEMBERS_INFO_1 - Structure for holding members details</span><br><span class="line">            [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]</span><br><span class="line">            public struct LOCALGROUP_MEMBERS_INFO_1</span><br><span class="line">            &#123;</span><br><span class="line">                public int lgrmi1_sid;</span><br><span class="line">                public int lgrmi1_sidusage;</span><br><span class="line">                public string lgrmi1_name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            int EntriesRead;</span><br><span class="line">            int TotalEntries;</span><br><span class="line">            int Resume;</span><br><span class="line">            IntPtr bufPtr;</span><br><span class="line"></span><br><span class="line">            string groupName = &quot;Administrators&quot;;</span><br><span class="line"></span><br><span class="line">            NetworkAPI.NetLocalGroupGetMembers(null, groupName, 1, out bufPtr, -1, out EntriesRead, out TotalEntries, out Resume);</span><br><span class="line"></span><br><span class="line">            if (EntriesRead &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                NetworkAPI.LOCALGROUP_MEMBERS_INFO_1[] Members = new NetworkAPI.LOCALGROUP_MEMBERS_INFO_1[EntriesRead];</span><br><span class="line">                IntPtr iter = bufPtr;</span><br><span class="line">                for (int i = 0; i &lt; EntriesRead; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Members[i] = (NetworkAPI.LOCALGROUP_MEMBERS_INFO_1)Marshal.PtrToStructure(iter, typeof(NetworkAPI.LOCALGROUP_MEMBERS_INFO_1));</span><br><span class="line">                    iter = (IntPtr)((int)iter + Marshal.SizeOf(typeof(NetworkAPI.LOCALGROUP_MEMBERS_INFO_1)));</span><br><span class="line">                    Console.WriteLine(Members[i].lgrmi1_name);</span><br><span class="line">                &#125;</span><br><span class="line">                NetworkAPI.NetApiBufferFree(bufPtr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/bloodhound技术分析\2019-09-20-12-28-01.jpg" alt></p>
<p><strong>NetLocalGroupGetMembers</strong>函数检索安全数据库中<strong>特定的本地组</strong>，它从安全帐户管理器（SAM）数据库，或在域控制器上（在Active Directory）枚举成员名单。本地组成员可以是用户或全局组。也就是说，在非域控的机器下枚举只能是本地组用户，在域控下运行可以枚举本地组或者全局组。（需要在域内使用，如果是工作组，无法获取远程计算机的成员组用户，只能获取本地成员组用户）</p>
<p>通过遍历DNS或者NetBIOS名称便可以获取所有机器的特定本地组的用户名</p>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-11.jpg" alt></p>
<h3 id="扩展思路"><a href="#扩展思路" class="headerlink" title="扩展思路"></a><strong>扩展思路</strong></h3><p>1.拿到的用户名可以作为爆破使用。</p>
<p>2.确认域管、域控机器。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>无论是否指定隐秘，会话集合都是相同的。BloodHound公开了两种不同的查询计算机会话信息的方法。两种方法都从检查端口445开始，然后发散。</p>
<h3 id="默认会话"><a href="#默认会话" class="headerlink" title="默认会话"></a>默认会话</h3><p>会话收集的默认方法使用<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb525382(v=vs.85" target="_blank" rel="noopener">NetSessionEnum NETAPI32</a>.aspx)调用。它不允许直接查询系统以询问谁登录。相反，它允许查询系统以确定为该系统建立的网络会话以及从<strong>何处访问</strong>。在访问网络资源（例如文件共享）时创建网络会话。</p>
<p>该函数提供有关在服务器上建立的会话的信息。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS NET_API_FUNCTION <span class="title">NetSessionEnum</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LMSTR   servername,</span></span></span><br><span class="line"><span class="function"><span class="params">  LMSTR   UncClientName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LMSTR   username,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   level,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE  *bufptr,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   prefmaxlen,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD entriesread,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD totalentries,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD resume_handle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><p>servername</p>
<p>指向字符串的指针，该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为<strong>NULL</strong>，则使用本地计算机。</p>
<p>UncClientName</p>
<p>指向字符串的指针，该字符串指定要为其返回信息的计算机会话的名称。如果此参数为<strong>NULL</strong>，则 <strong>NetSessionEnum</strong>将返回服务器上所有计算机会话的信息。</p>
<p>username</p>
<p>指向字符串的指针，该字符串指定要为其返回信息的用户的名称。如果此参数为<strong>NULL</strong>，则 <strong>NetSessionEnum</strong>将返回所有用户的信息。</p>
<p>level</p>
<p>指定数据的信息级别。此参数可以是以下值之一。</p>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left">返回建立会话的计算机的名称。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_0" target="_blank" rel="noopener">SESSION_INFO_0</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>1</strong></td>
<td style="text-align:left">返回计算机的名称，用户的名称以及打开计算机上的文件，管道和设备。所述<em>bufptr</em> 参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_1" target="_blank" rel="noopener">SESSION_INFO_1</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>2</strong></td>
<td style="text-align:left">除了为级别1指示的信息之外，还返回客户端的类型以及用户如何建立会话。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_2" target="_blank" rel="noopener">SESSION_INFO_2</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>10</strong></td>
<td style="text-align:left">返回计算机的名称，用户的名称以及会话的活动和空闲时间。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_10" target="_blank" rel="noopener">SESSION_INFO_10</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>502</strong></td>
<td style="text-align:left">返回计算机的名称; 用户名; 打开计算机上的文件，管道和设备; 以及客户端正在使用的传输的名称。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_502" target="_blank" rel="noopener">SESSION_INFO_502</a>结构。</td>
</tr>
</tbody>
</table>
<p>例如，API调用可以像这样运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetSessionEnum(&quot;primary.testlab.local&quot;, null, null, 10, out IntPtr ptrInfo, -1, out int EntriesRead, out int _, ref resumeHandle);</span><br></pre></td></tr></table></figure>
<p>API调用的第四个参数是API调用的<strong>级别</strong>，其中10是唯一以未经身份验证的方式为BloodHound提供所需数据的级别。（级别1、2需要administrators或者Server Operators本地组的成员身份）。因此，使用该函数时不需要高权限。</p>
<p>对具有已安装的共享驱动器的域控制器运行此操作将显示类似于以下的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sesi10_cname - 192.168.1.10</span><br><span class="line">sesi10_username - rvazarkar</span><br><span class="line">sesi10_time - 0</span><br><span class="line">sesi10_idle_time - 0</span><br></pre></td></tr></table></figure>
<p>该sesi10_cname参数指示，其中会话是从哪里来的，所以主机名可以让我们的会话到远程主机相关解析这个IP地址。这通常是您可能看不到已知存在的登录会话的原因。如果外部网络会话不存在，则SharpHound的未经身份验证的收集方法无法枚举此数据。同样重要的是要注意，username参数没有与之关联的域，这意味着会话信息包含涉及猜测的元素。SharpHound使用全局编录来尝试消除冲突用户的冲突，并确定哪个域是正确的域，但不能保证它会选择正确的域。</p>
<p>session的获取主要通过域控及共享</p>
<p>NetSessionEnum sample code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static SESSION_INFO_10[] EnumSessions(string server)</span><br><span class="line">        &#123;</span><br><span class="line">            IntPtr BufPtr;</span><br><span class="line">            int res = 0;</span><br><span class="line">            Int32 er = 0, tr = 0, resume = 0;</span><br><span class="line">            BufPtr = (IntPtr)Marshal.SizeOf(typeof(SESSION_INFO_10));</span><br><span class="line">            SESSION_INFO_10[] results = new SESSION_INFO_10[0];</span><br><span class="line">            do</span><br><span class="line">            &#123;</span><br><span class="line">                res = NetSessionEnum(server, null, null, 10, out BufPtr, -1, ref er, ref tr, ref resume);</span><br><span class="line">                results = new SESSION_INFO_10[er];</span><br><span class="line">                if (res == (int)NERR.ERROR_MORE_DATA || res == (int)NERR.NERR_Success)</span><br><span class="line">                &#123;</span><br><span class="line">                    Int32 p = BufPtr.ToInt32();</span><br><span class="line">                    for (int i = 0; i &lt; er; i++)</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        SESSION_INFO_10 si = (SESSION_INFO_10)Marshal.PtrToStructure(new IntPtr(p), typeof(SESSION_INFO_10));</span><br><span class="line">                        results[i] = si;</span><br><span class="line">                        p += Marshal.SizeOf(typeof(SESSION_INFO_10));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Marshal.FreeHGlobal(BufPtr);</span><br><span class="line">            &#125;</span><br><span class="line">            while (res == (int)NERR.ERROR_MORE_DATA);</span><br><span class="line">            return results;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-02.jpg" alt></p>
<h4 id="扩展思路-1"><a href="#扩展思路-1" class="headerlink" title="扩展思路"></a>扩展思路</h4><p>1.通过服务器建立session信息搜集IP资产</p>
<h3 id="LoggedOn会话"><a href="#LoggedOn会话" class="headerlink" title="LoggedOn会话"></a>LoggedOn会话</h3><p>该<strong>LoggedOn</strong>收集方法是通过询问是谁在对系统实际登录的计算机返回会话信息的更精确的收集方法。需要注意的是，此级别的集合<strong>需要</strong>您要从中收集数据的主机的<strong>管理</strong>权限。此会话集非常适合防御者，或在获得域管理员后进行其他数据收集。该<strong>LoggedOn</strong>收集方法采用两种不同的方法来收集数据。第一种方法是使用<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370669(v=vs.85" target="_blank" rel="noopener">NetWkstaUserEnum NETAPI32</a>.aspx) API调用。</p>
<p>该函数可以列出当前登录到该工作站的所有用户的信息。此列表包括交互式，服务和批量登录。</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS NET_API_FUNCTION <span class="title">NetSessionEnum</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LMSTR   servername,</span></span></span><br><span class="line"><span class="function"><span class="params">  LMSTR   UncClientName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LMSTR   username,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   level,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPBYTE  *bufptr,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD   prefmaxlen,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD entriesread,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD totalentries,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD resume_handle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><p>servername</p>
<p>指向字符串的指针，该字符串指定要在其上执行函数的远程服务器的DNS或NetBIOS名称。如果此参数为<strong>NULL</strong>，则使用本地计算机。</p>
<p>UncClientName</p>
<p>指向字符串的指针，该字符串指定要为其返回信息的计算机会话的名称。如果此参数为<strong>NULL</strong>，则 <strong>NetSessionEnum</strong>将返回服务器上所有计算机会话的信息。</p>
<p>username</p>
<p>指向字符串的指针，该字符串指定要为其返回信息的用户的名称。如果此参数为<strong>NULL</strong>，则 <strong>NetSessionEnum</strong>将返回所有用户的信息。</p>
<p>level</p>
<p>指定数据的信息级别。此参数可以是以下值之一。</p>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>0</strong></td>
<td style="text-align:left">返回建立会话的计算机的名称。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_0" target="_blank" rel="noopener">SESSION_INFO_0</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>1</strong></td>
<td style="text-align:left">返回计算机的名称，用户的名称以及打开计算机上的文件，管道和设备。所述<em>bufptr</em> 参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_1" target="_blank" rel="noopener">SESSION_INFO_1</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>2</strong></td>
<td style="text-align:left">除了为级别1指示的信息之外，还返回客户端的类型以及用户如何建立会话。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_2" target="_blank" rel="noopener">SESSION_INFO_2</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>10</strong></td>
<td style="text-align:left">返回计算机的名称，用户的名称以及会话的活动和空闲时间。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_10" target="_blank" rel="noopener">SESSION_INFO_10</a>结构。</td>
</tr>
<tr>
<td style="text-align:left"><strong>502</strong></td>
<td style="text-align:left">返回计算机的名称; 用户名; 打开计算机上的文件，管道和设备; 以及客户端正在使用的传输的名称。所述<em>bufptr</em>参数指向的数组 <a href="https://docs.microsoft.com/windows/desktop/api/lmshare/ns-lmshare-session_info_502" target="_blank" rel="noopener">SESSION_INFO_502</a>结构。</td>
</tr>
</tbody>
</table>
<p>此API调用的示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NetWkstaUserEnum(&quot;primary.testlab.local&quot;, 1, out IntPtr intPtr, -1, out int entriesRead, out int _, ref resumeHandle);</span><br></pre></td></tr></table></figure>
<p>API调用的第二个参数是API调用的<strong>级别</strong>，其中1个返回的数据多于0。对系统执行此操作会产生如下数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wkui1_username - rvazarkar</span><br><span class="line">wkui1_logon_domain - TESTLAB</span><br><span class="line">wkui1_oth_domains -</span><br><span class="line">wkui1_logon_server - PRIMARY</span><br></pre></td></tr></table></figure>
<p>NetWkstaUserEnum sample code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static WKSTA_USER_INFO_1[] EnumWkstaUser(string server)</span><br><span class="line">        &#123;</span><br><span class="line">            IntPtr Bufptr;</span><br><span class="line">            int nStatus = 0;</span><br><span class="line">            Int32 dwEntriesread = 0, dwTotalentries = 0, dwResumehandle = 0;</span><br><span class="line"></span><br><span class="line">            Bufptr = (IntPtr)Marshal.SizeOf(typeof(WKSTA_USER_INFO_1));</span><br><span class="line">            WKSTA_USER_INFO_1[] results = new WKSTA_USER_INFO_1[0];</span><br><span class="line">            do</span><br><span class="line">            &#123;</span><br><span class="line">                nStatus = NetWkstaUserEnum(server, 1, out Bufptr, 32768, out dwEntriesread, out dwTotalentries, ref dwResumehandle);</span><br><span class="line">                results = new WKSTA_USER_INFO_1[dwEntriesread];</span><br><span class="line">                if ((nStatus == NERR_SUCCESS) || (nStatus == ERROR_MORE_DATA))</span><br><span class="line">                &#123;</span><br><span class="line">                    if (dwEntriesread &gt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        IntPtr pstruct = Bufptr;</span><br><span class="line">                        for (int i = 0; i &lt; dwEntriesread; i++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            WKSTA_USER_INFO_1 wui1 = (WKSTA_USER_INFO_1)Marshal.PtrToStructure(pstruct, typeof(WKSTA_USER_INFO_1));</span><br><span class="line">                            results[i] = wui1;</span><br><span class="line">                            pstruct = (IntPtr)((int)pstruct + Marshal.SizeOf(typeof(WKSTA_USER_INFO_1)));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        //Console.WriteLine(&quot;A system error has occurred : &quot; + nStatus);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (Bufptr != IntPtr.Zero)</span><br><span class="line">                    NetApiBufferFree(Bufptr);</span><br><span class="line"></span><br><span class="line">            &#125; while (nStatus == ERROR_MORE_DATA);</span><br><span class="line">            return results;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/bloodhound技术分析/2019-09-20-12-28-09.jpg" alt></p>
<p>LoggedOn集合方法使用的辅助枚举方法是使用远程注册表。SharpHound将尝试打开远程注册表的用户配置单元（如果已启用），并将查找与 SID 格式匹配的子项，这些对应于登录用户将获取的 SID 转换成用户名即可。一般来说，需要域管权限去操作，而在极少数情况下，无需管理员权限即可访问此数据 。</p>
<p>Reg sample code </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static IEnumerable&lt;string&gt; GetRegistryLoggedOn(string server)</span><br><span class="line">        &#123;</span><br><span class="line">var users = new List&lt;string&gt;();</span><br><span class="line">try</span><br><span class="line">            &#123;</span><br><span class="line">// 远程打开注册表配置单元，如果它不是我们当前的配置单元</span><br><span class="line">RegistryKey key = RegistryKey.OpenRemoteBaseKey(RegistryHive.Users, server);</span><br><span class="line">// 找到与我们的正则表达式匹配的所有子项</span><br><span class="line">var filtered = key.GetSubKeyNames().Where(sub =&gt; SidRegex.IsMatch(sub));</span><br><span class="line">foreach (var subkey in filtered)</span><br><span class="line">                &#123;</span><br><span class="line">users.Add(subkey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">catch (Exception)</span><br><span class="line">            &#123;</span><br><span class="line">yield break;</span><br><span class="line">            &#125;</span><br><span class="line">foreach (var user in users.Distinct())</span><br><span class="line">            &#123;</span><br><span class="line">yield return user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="组成员关系"><a href="#组成员关系" class="headerlink" title="组成员关系"></a>组成员关系</h2><p>所有域组成员资格集合都通过LDAP完成。SharpHound将向域控制器询问域中每个组，用户和计算机对象的列表，并使用<strong>MemberOf</strong>属性来解析组成员身份。组成员关系集合不需要触及域控制器以外的任何系统。</p>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>所有AD对象ACL集合都是通过LDAP完成的。SharpHound将向域控制器询问域中每个用户，组，计算机和域对象的列表，并使用<strong>NTSecurityDescriptor</strong>属性来解析访问控制列表。ACL集合不需要触及域控制器以外的任何系统。</p>
<h2 id="域信任关系"><a href="#域信任关系" class="headerlink" title="域信任关系"></a>域信任关系</h2><p>信任收集使用<a href="https://msdn.microsoft.com/en-us/library/ms675976(v=vs.85" target="_blank" rel="noopener">DsEnumerateDomainTrusts NETAPI32</a>.aspx) API调用执行。运行此查询的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DsEnumerateDomainTrusts(&quot;testlab.local&quot;, 63, out IntPtr ptr, out int domainCount);</span><br></pre></td></tr></table></figure>
<p>第二个参数是一组标志，用于指定要返回的信任类型。63对应于所有可能的标志：</p>
<ul>
<li>DS_DOMAIN_IN_FOREST</li>
<li>DS_DOMAIN_DIRECT_OUTBOUND</li>
<li>DS_DOMAIN_TREE_ROOT</li>
<li>DS_DOMAIN_PRIMARY</li>
<li>DS_DOMAIN_NATIVE_MODE</li>
<li>DS_DOMAIN_DIRECT_INBOUND</li>
</ul>
<p>这将返回所有可能的域类型</p>
<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><p>所有属性集合都通过LDAP完成。SharpHound将向域控制器询问域中每个用户和计算机对象的列表，并为每个对象请求几个不同的属性。</p>
<p>对于用户对象，使用以下属性：</p>
<ul>
<li>SamAccountName</li>
<li>DistinguishedName</li>
<li>SaMAccountType</li>
<li>PwdLastSet</li>
<li>LastLogon</li>
<li>SidHistory</li>
<li>UserAccountControl</li>
<li>Mail</li>
<li>ObjectSid</li>
<li>ServicePrincipalName</li>
<li>DisplayName</li>
</ul>
<p>对于计算机对象，使用以下属性：</p>
<ul>
<li>SaMAccountName</li>
<li>DistinguishedName</li>
<li>SaMAccountType</li>
<li>ObjectSid</li>
<li>UserAccountControl</li>
<li>DNSHostName</li>
<li>OperatingSystemServicePack</li>
<li>OperatingSystem</li>
</ul>
<h1 id="每种收集方法的目标是什么系统？"><a href="#每种收集方法的目标是什么系统？" class="headerlink" title="每种收集方法的目标是什么系统？"></a>每种收集方法的目标是什么系统？</h1><p>SharpHound根据提供的标记显着改变目标选择。SharpHound使用的默认收集方法非常粗暴，触及可到达的域上的每个系统。使用隐形标志可显着降低目标系统的数量。</p>
<h2 id="本地管理员-非隐秘"><a href="#本地管理员-非隐秘" class="headerlink" title="本地管理员 - 非隐秘"></a>本地管理员 - 非隐秘</h2><p>没有隐秘标志的本地管理员集合将覆盖每个可到达的域计算机以收集数据。这提供了可靠和准确的结果。</p>
<h2 id="本地管理员-隐秘"><a href="#本地管理员-隐秘" class="headerlink" title="本地管理员 - 隐秘"></a>本地管理员 - 隐秘</h2><p>具有隐秘标志的本地管理员集合完全依赖于组策略设置，并且不需要触摸除SYSVOL文件夹中包含相关文件的域控制器之外的任何系统。隐秘收集返回的数据质量因域而异，因为某些域不使用GPO来管理本地管理员设置，而其他域则仅使用它。GPO不会反映所做的本地更改，因此使用此方法将无法找到添加到本地管理员组的其他原则。</p>
<h2 id="会话-非隐秘"><a href="#会话-非隐秘" class="headerlink" title="会话 - 非隐秘"></a>会话 - 非隐秘</h2><p>没有隐秘标志的会话集合将覆盖每个可到达的域计算机以收集数据。</p>
<h2 id="会话-隐秘"><a href="#会话-隐秘" class="headerlink" title="会话 - 隐秘"></a>会话 - 隐秘</h2><p>具有隐秘标志的会话集合极大地限制了用于收集的系统的数量。SharpHound将使用LDAP中的<strong>UserAccountControl</strong>属性将所有标记为域控制器的计算机作为目标。还将请求具有任何<strong>HomeDirectory</strong>，<strong>ScriptPath</strong>或<strong>ProfilePath</strong>属性集的所有Active Directory对象的列表。从这些属性创建一组唯一的服务器名称，以标识会话收集的其他目标。平均而言，隐形会话收集将收集域中约50-60％的会话信息。这可能会因域的结构而异，但大多数网络会话通常指向域控制器或文件服务器。</p>
<h2 id="组-隐秘与非隐秘"><a href="#组-隐秘与非隐秘" class="headerlink" title="组- 隐秘与非隐秘"></a>组- 隐秘与非隐秘</h2><p>组集合仅需要与域控制器通信以请求LDAP数据。</p>
<h2 id="ACL-隐秘和非隐秘"><a href="#ACL-隐秘和非隐秘" class="headerlink" title="ACL - 隐秘和非隐秘"></a>ACL - 隐秘和非隐秘</h2><p>ACL集合仅需要与域控制器通信以请求LDAP数据。</p>
<h2 id="信任关系-隐秘和非隐秘"><a href="#信任关系-隐秘和非隐秘" class="headerlink" title="信任关系 - 隐秘和非隐秘"></a>信任关系 - 隐秘和非隐秘</h2><p>信任收集需要与映射的每个域中的一个域控制器进行通信。</p>
<h2 id="对象属性-隐秘和非隐秘"><a href="#对象属性-隐秘和非隐秘" class="headerlink" title="对象属性 - 隐秘和非隐秘"></a>对象属性 - 隐秘和非隐秘</h2><p>对象属性集合需要与域控制器通信以请求LDAP数据。</p>
<h1 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h1><h2 id="Cheat-Sheets"><a href="#Cheat-Sheets" class="headerlink" title="Cheat Sheets"></a>Cheat Sheets</h2><table>
<thead>
<tr>
<th style="text-align:left">Collection Method</th>
<th style="text-align:center">API Call</th>
<th style="text-align:center">Default Targets</th>
<th style="text-align:left">Stealth Targets</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Session</td>
<td style="text-align:center"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb525382(v=vs.85" target="_blank" rel="noopener">NetSessionEnum</a>.aspx)</td>
<td style="text-align:center">All Computers</td>
<td style="text-align:left">Domain Controllers + “Share Servers”</td>
</tr>
<tr>
<td style="text-align:left">LocalGroup</td>
<td style="text-align:center">Modified <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370601(v=vs.85" target="_blank" rel="noopener">NetLocalGroupGetMembers</a>.aspx)</td>
<td style="text-align:center">All Computers</td>
<td style="text-align:left">GPO Files</td>
</tr>
<tr>
<td style="text-align:left">Group</td>
<td style="text-align:center">Ldap</td>
<td style="text-align:center">All User,Group, and Computer Objects</td>
<td style="text-align:left">All User,Group, and Computer Objects</td>
</tr>
<tr>
<td style="text-align:left">Trusts</td>
<td style="text-align:center"><a href="https://msdn.microsoft.com/en-us/library/ms675976(v=vs.85" target="_blank" rel="noopener">DsEnumerateDomainTrusts NETAPI32</a>.aspx)</td>
<td style="text-align:center">All Domain and TrustedDomain objects</td>
<td style="text-align:left">All Domain and TrustedDomain objects</td>
</tr>
<tr>
<td style="text-align:left">LoggedOn</td>
<td style="text-align:center"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370669(v=vs.85" target="_blank" rel="noopener">NetWkstaUserEnum NETAPI32</a>.aspx) + Remote Registry</td>
<td style="text-align:center">All Computers</td>
<td style="text-align:left">Domain Controllers + “Share Servers”</td>
</tr>
<tr>
<td style="text-align:left">ACL</td>
<td style="text-align:center">Ldap</td>
<td style="text-align:center">All user, group, computer, and domain objects</td>
<td style="text-align:left">All user, group, computer, and domain objects</td>
</tr>
<tr>
<td style="text-align:left">ObjectProps</td>
<td style="text-align:center">Ldap</td>
<td style="text-align:center">All user and computer objects</td>
<td style="text-align:left">All user and computer objects</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">API Call</th>
<th style="text-align:center">Protocol</th>
<th style="text-align:center">Port</th>
<th style="text-align:left">RPC Interface UUID</th>
<th style="text-align:left">Named Pipe</th>
<th style="text-align:left">RPC Method</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/bb525382(v=vs.85" target="_blank" rel="noopener">NetSessionEnum</a>.aspx)</td>
<td style="text-align:center">[MS-SRVS]: Server Service Remote Protocol</td>
<td style="text-align:center">TCP 445</td>
<td style="text-align:left">4B324FC8-1670-01D3-1278-5A47BF6EE188</td>
<td style="text-align:left">\PIPE\srvsvc</td>
<td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/cc247273.aspx" target="_blank" rel="noopener">NetrSessionEnum</a></td>
</tr>
<tr>
<td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa370669(v=vs.85" target="_blank" rel="noopener">NetWkstaUserEnum</a>.aspx)</td>
<td style="text-align:center">[MS-WKST]: Workstation Service Remote Protocol</td>
<td style="text-align:center">TCP 445</td>
<td style="text-align:left">6BFFD098-A112-3610-9833-46C3F87E345A</td>
<td style="text-align:left">\PIPE\wkssvc</td>
<td style="text-align:left"><a href="https://msdn.microsoft.com/en-us/library/cc250349.aspx" target="_blank" rel="noopener">NetrWkstaUserEnum</a></td>
</tr>
</tbody>
</table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.cptjesus.com/posts/sharphoundtechnical" target="_blank" rel="noopener">https://blog.cptjesus.com/posts/sharphoundtechnical</a></p>
<p><a href="https://blog.cptjesus.com/posts/sharphoundtargeting" target="_blank" rel="noopener">https://blog.cptjesus.com/posts/sharphoundtargeting</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">rootrain</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rootrain.me/2020/02/29/bloodhound技术分析/">https://rootrain.me/2020/02/29/bloodhound技术分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/bloodhound/">bloodhound</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2020/02/29/浅析gMSA/"><span>浅析gMSA</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2020/02/29/BlO4umfeQ8Ao9D3.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By rootrain</div><div class="framework-info"></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>