<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="内网防御规避(一)-使用blockdlls保护你的代码"><meta name="keywords" content="DLL注入"><meta name="author" content="rootrain"><meta name="copyright" content="rootrain"><title>内网防御规避(一)-使用blockdlls保护你的代码 | rootrain's Home</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-前言"><span class="toc-number">1.</span> <span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-cobaltstrike中的blockdlls"><span class="toc-number">2.</span> <span class="toc-text">0x01 cobaltstrike中的blockdlls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-创建blockdlls进程"><span class="toc-number">3.</span> <span class="toc-text">0x02 创建blockdlls进程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-修改当前进程并开启blockdlls"><span class="toc-number">4.</span> <span class="toc-text">0x03 修改当前进程并开启blockdlls</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-查询安全策略"><span class="toc-number">5.</span> <span class="toc-text">0x04 查询安全策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-后语"><span class="toc-number">6.</span> <span class="toc-text">0x05 后语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考链接"><span class="toc-number">7.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">rootrain</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2020/02/29/BlO4umfeQ8Ao9D3.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">rootrain's Home</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives/">Archives</a><a class="site-page" href="/tags/">Tags</a><a class="site-page" href="/categories/">Categories</a></span></div><div id="post-info"><div id="post-title">内网防御规避(一)-使用blockdlls保护你的代码</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-29</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/内网-防御规避/">内网,防御规避</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Cobalt Strike 3.14新增了blockdlls功能，该功能可以限定子进程只能加载带有微软签名的dll。</p>
<p>通过该特性我们可以防止第三方的应用（如安全软件）对子进程进行DLL注入，避免安全软件对我们的程序进行查杀。</p>
<a id="more"></a>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>Cobalt Strike 3.14新增了blockdlls功能，该功能可以限定子进程只能加载带有微软签名的dll。</p>
<p>通过该特性我们可以防止第三方的应用（如安全软件）对子进程进行DLL注入，避免安全软件对我们的程序进行查杀。</p>
<p>本文就来分析blockdlls功能的具体是如何实现的。</p>
<p><strong>本文重点</strong>：</p>
<ul>
<li>Cobaltstrike中的blockdlls</li>
<li>创建blockdlls进程</li>
<li>修改当前进程并开启blockdlls</li>
<li>通过API思考blockdlls的优劣性</li>
</ul>
<h1 id="0x01-cobaltstrike中的blockdlls"><a href="#0x01-cobaltstrike中的blockdlls" class="headerlink" title="0x01 cobaltstrike中的blockdlls"></a>0x01 cobaltstrike中的blockdlls</h1><p>先看一下cobaltstrike里面的介绍</p>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219144421603.png" alt></p>
<p>该功能在win10/win server 2012以上版本生效，可以通过该功能对子进程保护，非微软官方DLL不能加载进子进程。</p>
<p>在非win10之前的系统上执行，会返回非win8以后系统，因此我们可以大概推断，该功能准确来说应该是win8之后的系统生效。</p>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219144822381.png" alt></p>
<p>功能操作也很简单，blockdlls [start/stop]，分别是开启与关闭。</p>
<h1 id="0x02-创建blockdlls进程"><a href="#0x02-创建blockdlls进程" class="headerlink" title="0x02 创建blockdlls进程"></a>0x02 创建blockdlls进程</h1><p>创建blockdlls进程需要用到的函数是<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute" target="_blank" rel="noopener">UpdateProcThreadAttribute</a>，其中需要注意的是：lpValue是指向属性值的指针。该值应保持不变，直到使用<a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-deleteprocthreadattributelist" target="_blank" rel="noopener">DeleteProcThreadAttributeList</a>函数销毁该属性为止。</p>
<p>首先我们来看C++代码，XPN在博客中分享了实现同样功能的c代码，地址如下：</p>
<p><a href="https://blog.xpnsec.com/protecting-your-malware/" target="_blank" rel="noopener">https://blog.xpnsec.com/protecting-your-malware/</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	STARTUPINFOEXA si;</span><br><span class="line">	PROCESS_INFORMATION pi;</span><br><span class="line">	SIZE_T size = <span class="number">0</span>;</span><br><span class="line">	BOOL ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Required for a STARTUPINFOEXA</span></span><br><span class="line">	ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">	si.StartupInfo.cb = <span class="keyword">sizeof</span>(STARTUPINFOEXA);</span><br><span class="line">	si.StartupInfo.dwFlags = EXTENDED_STARTUPINFO_PRESENT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the size of our PROC_THREAD_ATTRIBUTE_LIST to be allocated</span></span><br><span class="line">	InitializeProcThreadAttributeList(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>, &amp;size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate memory for PROC_THREAD_ATTRIBUTE_LIST</span></span><br><span class="line">	si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(</span><br><span class="line">		GetProcessHeap(),</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">		size</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialise our list </span></span><br><span class="line">	InitializeProcThreadAttributeList(si.lpAttributeList, <span class="number">1</span>, <span class="number">0</span>, &amp;size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Enable blocking of non-Microsoft signed DLLs</span></span><br><span class="line">	DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Assign our attribute</span></span><br><span class="line">	UpdateProcThreadAttribute(si.lpAttributeList, <span class="number">0</span>, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &amp;policy, <span class="keyword">sizeof</span>(policy), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, create the process</span></span><br><span class="line">	ret = CreateProcessA(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		(LPSTR)<span class="string">"C:\\Windows\\System32\\cmd.exe"</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		EXTENDED_STARTUPINFO_PRESENT,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		<span class="keyword">reinterpret_cast</span>&lt;LPSTARTUPINFOA&gt;(&amp;si),</span><br><span class="line">		&amp;pi</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据xpn对cobaltstrike beacon的分析，我们可以知道该关键函数UpdateProcThreadAttribute，并可以知道PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY的值为0x20007，PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON的值为0x100000000000。</p>
<p>简单说明一下UpdateProcThreadAttribute函数的输入参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lpAttributeList</span><br></pre></td></tr></table></figure>
<p>指向由<a href="https://docs.microsoft.com/windows/desktop/api/processthreadsapi/nf-processthreadsapi-initializeprocthreadattributelist" target="_blank" rel="noopener">InitializeProcThreadAttributeList</a>函数创建的属性列表的指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Attribute</span><br></pre></td></tr></table></figure>
<p>在属性列表中更新的属性键。其中的PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY属性便是blockdlls的主角，通过修改该值可以起到了阻止加载非Microsoft签名dll的作用。</p>
<p>之后我用C#代码又实现了一遍UpdateProcThreadAttribute函数的过程。为了用C#实现还是踩了很多坑，最坑的地方就是需要写入cbSize（lpValue参数指定的属性值的大小），不能设为IntPtr.Zero。</p>
<p>首先需要通过STARTUPINFOEX结构体指定了要创建子进程的安全策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[StructLayout(LayoutKind.Sequential)]</span><br><span class="line">        public struct STARTUPINFOEX</span><br><span class="line">        &#123;</span><br><span class="line">            public STARTUPINFO StartupInfo;</span><br><span class="line">            public IntPtr lpAttributeList;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>以及其他需要的结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[StructLayout(LayoutKind.Sequential)]</span><br><span class="line">        public struct PROCESS_INFORMATION</span><br><span class="line">        &#123;</span><br><span class="line">            public IntPtr hProcess;</span><br><span class="line">            public IntPtr hThread;</span><br><span class="line">            public int dwProcessId;</span><br><span class="line">            public int dwThreadId;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[StructLayout(LayoutKind.Sequential)]</span><br><span class="line">        public struct SECURITY_ATTRIBUTES</span><br><span class="line">        &#123;</span><br><span class="line">            public int nLength;</span><br><span class="line">            public IntPtr lpSecurityDescriptor;</span><br><span class="line">            public int bInheritHandle;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[StructLayout(LayoutKind.Sequential)]</span><br><span class="line">        public struct DWORD64</span><br><span class="line">        &#123;</span><br><span class="line">            public uint dwPart1;</span><br><span class="line">            public uint dwPart2;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>实现函数功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public static bool CreateProcess()</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            var pInfo = new PROCESS_INFORMATION();</span><br><span class="line">            STARTUPINFOEX sInfoEx = new STARTUPINFOEX();</span><br><span class="line"></span><br><span class="line">            sInfoEx.StartupInfo.cb = (uint)Marshal.SizeOf(sInfoEx);</span><br><span class="line">            IntPtr lpValue = IntPtr.Zero;</span><br><span class="line"></span><br><span class="line">            SECURITY_ATTRIBUTES pSec = new SECURITY_ATTRIBUTES();</span><br><span class="line">            SECURITY_ATTRIBUTES tSec = new SECURITY_ATTRIBUTES();</span><br><span class="line">            pSec.nLength = Marshal.SizeOf(pSec);</span><br><span class="line">            tSec.nLength = Marshal.SizeOf(tSec);</span><br><span class="line"></span><br><span class="line">            //从进程的非托管内存中分配内存</span><br><span class="line">            IntPtr pntpSec = Marshal.AllocHGlobal(Marshal.SizeOf(pSec));</span><br><span class="line">            Marshal.StructureToPtr(pSec, pntpSec, false);</span><br><span class="line">            IntPtr pnttSec = Marshal.AllocHGlobal(Marshal.SizeOf(tSec));</span><br><span class="line">            Marshal.StructureToPtr(tSec, pnttSec, false);</span><br><span class="line"></span><br><span class="line">            IntPtr lpSize = IntPtr.Zero;</span><br><span class="line"></span><br><span class="line">            //初始化指定的属性列表以创建进程和线程</span><br><span class="line">            InitializeProcThreadAttributeList(IntPtr.Zero, 1, 0, ref lpSize);</span><br><span class="line">            sInfoEx.lpAttributeList = Marshal.AllocHGlobal(lpSize);</span><br><span class="line">            InitializeProcThreadAttributeList(sInfoEx.lpAttributeList, 1, 0, ref lpSize);</span><br><span class="line"></span><br><span class="line">            //获取进程句柄</span><br><span class="line">            IntPtr parentHandle = Process.GetProcessById(1408).Handle;</span><br><span class="line">            lpValue = Marshal.AllocHGlobal(IntPtr.Size);</span><br><span class="line">            Marshal.WriteIntPtr(lpValue, parentHandle);</span><br><span class="line"></span><br><span class="line">            //获取要启动的进程路径</span><br><span class="line">            var lpApplicationName = Path.Combine(Environment.SystemDirectory, &quot;cmd.exe&quot;);</span><br><span class="line"></span><br><span class="line">            //设置将Microsoft only(blockdlls)</span><br><span class="line"></span><br><span class="line">            DWORD64 policy = new DWORD64();</span><br><span class="line">            policy.dwPart1 = 0;</span><br><span class="line">            policy.dwPart2 = 0x1000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            IntPtr lpMitigationPolicy = Marshal.AllocHGlobal(IntPtr.Size);</span><br><span class="line">            Marshal.WriteInt64(lpMitigationPolicy, PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON);</span><br><span class="line"></span><br><span class="line">            UpdateProcThreadAttribute(sInfoEx.lpAttributeList, 0, (IntPtr)PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, lpMitigationPolicy, (IntPtr)Marshal.SizeOf(policy), IntPtr.Zero, IntPtr.Zero);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (!CreateProcess(lpApplicationName, null, ref pSec, ref tSec, true, CreateSuspended | EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, IntPtr.Zero, null, ref sInfoEx, out pInfo))</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>C++与C#生成的代码略微不同，在对C++创建的进程进行DLL注入时会提示错误，而C#则没有。两者都不可以注入DLL文件。有对windows了解的大牛可以告诉我是什么原因。</p>
<p>C#：</p>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219160556881.png" alt></p>
<p>不能注入DLL，但没有报错。</p>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219160801561.png" alt></p>
<p>C++:</p>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219161023653.png" alt></p>
<p>注入DLL文件触发报错。</p>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219161204879.png" alt></p>
<h1 id="0x03-修改当前进程并开启blockdlls"><a href="#0x03-修改当前进程并开启blockdlls" class="headerlink" title="0x03 修改当前进程并开启blockdlls"></a>0x03 修改当前进程并开启blockdlls</h1><p>修改当前进程并开启blockdlls的原理是先获取当前进程的安全策略，然后再启用MicrosoftSignedOnly功能。这就需要用到两个API，获取进程安全策略<strong>GetProcessMitigationPolicy</strong>，修改进程安全策略<strong>SetProcessMitigationPolicy</strong>。</p>
<p>根据API文档，我们可以确定这两个函数都是在win8之后系统可用。</p>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219173019361.png" alt></p>
<p>3gstudent已经实现了win10系统下的<a href="https://github.com/3gstudent/Homework-of-C-Language/blob/master/SetProcessMitigationPolicy(Signature" target="_blank" rel="noopener">代码</a>ForWin10_CurrentProcess.cpp)，可以实现查询修改安全策略。其中在Win8系统，<a href="https://github.com/3gstudent/Homework-of-C-Language/blob/master/SetProcessMitigationPolicy(Signature" target="_blank" rel="noopener">代码</a>ForWin8_CurrentProcess.cpp)需要使用<code>NtQueryInformationProcess()</code>和<code>NtSetInformationProcess()</code>进行查看和修改安全策略。</p>
<h1 id="0x04-查询安全策略"><a href="#0x04-查询安全策略" class="headerlink" title="0x04 查询安全策略"></a>0x04 查询安全策略</h1><p>通过powershell可以查询出是否启用了MicrosoftSignedOnly功能。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-process</span> | select -exp processname -Unique | % &#123; Get-ProcessMitigation -ErrorAction SilentlyContinue -RunningProcesses <span class="variable">$_</span> | select processname, Id, @&#123;l=<span class="string">"Block non-MS Binaries"</span>; e=&#123;<span class="variable">$_</span>.BinarySignature|select -exp MicrosoftSignedOnly&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/内网防御规避（一）-使用blockdlls保护你的代码/image-20200219173752418.png" alt></p>
<h1 id="0x05-后语"><a href="#0x05-后语" class="headerlink" title="0x05 后语"></a>0x05 后语</h1><p>开启blockdlls后，我们可以稍微保护我们的代码，虽然目前已有不经过微软签名的DLL也能注入到进程当中，但对于大多数安全软件来说，该功能还是比较实用的。缺陷也很明显，就是系统要求比较高，需要在win8系统之后才会用到该功能。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://3gstudent.github.io/3gstudent.github.io/Cobalt_Strike的blockdlls利用分析/" target="_blank" rel="noopener">Cobalt_Strike的blockdlls利用分析</a></p>
<p><a href="https://blog.xpnsec.com/protecting-your-malware/" target="_blank" rel="noopener">Protecting Your Malware with blockdlls and ACG</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-updateprocthreadattribute</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocessmitigationpolicy</a></p>
<p><a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setprocessmitigationpolicy</a></p>
<p><a href="https://github.com/b4rtik/RedPeanut/" target="_blank" rel="noopener">https://github.com/b4rtik/RedPeanut/</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">rootrain</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://rootrain.me/2020/02/29/内网防御规避(一)-使用blockdlls保护你的代码/">https://rootrain.me/2020/02/29/内网防御规避(一)-使用blockdlls保护你的代码/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DLL注入/">DLL注入</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/29/内网防御规避(二)-命令行混淆/"><i class="fa fa-chevron-left">  </i><span>内网防御规避(二)-命令行混淆</span></a></div><div class="next-post pull-right"><a href="/2020/02/29/浅析命名管道/"><span>浅析命名管道</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2020/02/29/BlO4umfeQ8Ao9D3.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By rootrain</div><div class="framework-info"></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>